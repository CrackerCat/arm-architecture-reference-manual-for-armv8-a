## D4.2.11 Address translation instructions

Each of the ARMv8 instruction sets provides instructions that return the result of translating an input address, supplied as an argument to the instruction, using a specified translation stage or regime.

The available instructions only perform translations that are accessible from the Security state and Exception level at which the instruction is executed. That is:
* No instruction executed in Non-secure state can return the result of a Secure address translation stage.
* No instruction can return the result of an address translation stage that is controlled by an Exception level that is higher than the Exception level at which the instruction is executed.

[Address translation instructions, AT* on page D4-1692](#) summarizes the A64 address translation instructions. 

See also [A64 system instructions for address translation on page C5-334](#).


### Address translation instructions, AT*

The A64 assembly language syntax for address translation instructions is:

```
    AT <operation>, <Xt>
```

Where:

```
<operation> Is one of S1E1R, S1E1W, S1E0R, S1E0W, S12E1R, S12E1W, S12E0R, S12E0W, S1E2R, S1E2W, S1E3R, or S1E3W.
            <operation> has a structure of <stages><level><read|write>, where: 
            <stages> Is one of:
                     S1         Stage 1 translation.
                     S12        Stage 1 translation followed by stage 2 translation.
            <level> Describes the Exception Level that the translation applies to. Is one of:
                    E0          EL0.
                    E1          EL1.
                    E2          EL2.
                    E3          EL3.
                    If <level> is higher than the current Exception Level the instruction is UNDEFINED.
            <read|write>
                    Is one of:
                    R           Read. 
                    W           Write.
<Xt>        The address to be translated. No alignment restrictions apply for the address.
```

If EL2 is not implemented, the AT S1E2R and AT S1E2W instructions are UNDEFINED.

> **NOTE:**  
If EL2 is not implemented but EL3 is implemented, the AT S12E* instructions are not UNDEFINED, but behave the same way as the equivalent AT S1E* instructions. This is consistent with the behavior if EL2 is implemented but stage 2 translation is disabled.

For all of these instructions, the current context information determines which entries in TLB caching structures are used, and how the translation table walk is performed. However, it is IMPLEMENTATION DEFINED whether the Address translation instructions return the values held in a TLB or the result of a translation table walk. Therefore, ARM recommends that these instructions are not used at a time when the TLB entries might be different from the underlying translation tables held in memory.

When Non-secure EL1&0 stage 1 address translation is disabled, any AT S1E0\*, AT S1E1\*, AT S12E0\*, or ATS12E1\* address translation instruction that accesses the Non-secure state translation reflects the effect of the HCR_EL2.DC bit as described in [Behavior when stage 1 address translation is disabled on page D4-1677](#).

Executing AT S1E2R or AT S1E2W at EL3 with SCR_EL3.NS==0 is UNDEFINED.
> **NOTE:**  
AT S12E* instructions at EL3 with SCR_EL3.NS==0 are not UNDEFINED but behave the same way as the equivalent 
AT S1E* instructions.

***Synchronous faults generated by address translation instructions***

The address translation instructions use the translation mechanism, and that mechanism can generate the following synchronous faults:
* Translation fault.
* Access flag fault.
* Permission fault.
* Domain fault, when translating using the AArch32 translation systems.
* Address size fault.
* TLB conflict fault.
* Synchronous external aborts during a translation table walk.

In addition:
* If the address translation instruction requires two stages of translation then these faults could arise from either stage 1 or stage 2.
* For a stage 1 translation for the Non-secure EL1&0 translation regime, the fault might be generated on the stage 2 translation of an address accessed as part of the stage 1 translation table walk, see [Stage 2 fault on a stage 1 translation table walk on page D4-1726](#).




